# Shell的学习目标
* Shell的基本语法结构：
如：变量的定义、条件判断、循环语句（for、until、while）、分支语句、函数和数组等。
* 基本正则表达式的应用
* 文件处理：grep、sed、awk工具的使用
* 使用shell脚本完成复杂的任务：服务搭建、批量处理。

今日目标
* 掌握Shell变量的定义和获取
* Shell简单的四则运算
## 一、编程语言概述
计算机只能识别`机器语言（也就是二进制（0和1））`。但是又不能直接使用0和1，必须借助`人（工具）`来进行翻译成`机器语言`。而人（工具）就是常说的**编译器**或者是**解释器** 。

#### 编程语言的分类

![](https://github.com/SolerHo/Software-Testing/blob/master/Shell%E8%84%9A%E6%9C%AC%E7%9F%A5%E8%AF%86/Images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%86%E7%B1%BB.png)


* **编译型语言**
程序在执行之前需要一个`编译过程`，把程序编译为`机器语言文件`，运行时`不需要重新翻译`，直接`使用编译的结果`即可。程序执行效率高，以来编译器，跨平台性差，如C、C++。
* **解释型语言**
程序`不需要编译`，程序在运行时由`解释器`翻译成`机器语言`，每次执行一次都要翻译一次。效率比较低。如Python/Javascript/Perl/Ruby/Shell等这些都是解释型语言。

![](https://github.com/SolerHo/Software-Testing/blob/master/Shell%E8%84%9A%E6%9C%AC%E7%9F%A5%E8%AF%86/Images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%BE%8B%E5%AD%90%E5%88%86%E6%9E%90.png)

总结：
* 编译型语言比解释型速度较快，但是不如解释型语言跨平台性好。
* 如果做底层开发或者是大型应用程序或者操作系统一般都用编译型语言。
* 如果是一些服务器脚本及一些辅助的接口，对速度要要求不高。
* 对于各个平台的兼容性问题的话一般则是解释型语言。


## 二、Shell概述
Shell介于`用户`和`内核`之间，负责命令的解释。

![](https://github.com/SolerHo/Software-Testing/blob/master/Shell%E8%84%9A%E6%9C%AC%E7%9F%A5%E8%AF%86/Images/shell%E7%BB%93%E6%9E%84%E5%9B%BE.png)

总结：
shell是人机交互的`媒介`。

shell的种类：
```
[solerho@localhost ~]$ cat /etc/shells
/bin/sh                                        # 是bash的一个快捷方式
/bin/bash                                    # bash是大多数Linux默认的Shell，包含的功能几乎涵盖了shell的所有功能。
/usr/bin/sh                                   
/usr/bin/bash
```

#### 1、什么是Shell脚本？
需要执行的命令保存到文本中，按照顺序执行。`解释型的语言，所以不需要编译`。

可以使用公式来描述：
```
若干命令 + 脚本基本格式 + 脚本特定语法 + 思想  = Shell脚本
```

#### 2、Shell脚本的用途
* 自动化软件部署
    * LAMP/LNMP/Tomcat
* 自动化管理
    * 系统初始化脚本、批量更改主机密码、推送公钥等。
* 自动化分析处理
    * 统计网站访问量
* 自动化备份
    * 数据库备份、日志转储。
* 自动化监控脚本

#### 3、Shell脚本的基本写法
3.1 **脚本的第一行**：`字符#!指定解释器`【必写】

`#!/bin/bash` 表示以下内容使用bash解释器解析。

注意点：
如果直接将解释器路径固定在脚本里，可能有些系统会存在`找不到解释器的兼容性问题`，所以，可以使用 `#!/bin/env 解释器`进行解析。

3.2 **脚本的第二部分**：`注释（#）号`说明，对脚本的基本信息进行`描述`。
例如：
```
#!/bin/env bash

# Name:Soler HO
# Desc:description
# path:存放路径

# 下面是脚本的具体内容
commands
…...
```

3.3 **脚本的第三部分**：脚本要实现的`具体代码内容`。

#### 4、Shell脚本的执行方式
![](https://github.com/SolerHo/Software-Testing/blob/master/Shell%E8%84%9A%E6%9C%AC%E7%9F%A5%E8%AF%86/Images/shell%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%9A%84%E6%96%B9%E5%BC%8F.png)

4.1 切换到shell脚本所在的目录（此时叫做工作目录）执行shell脚本

4.2 以绝对路径的方式去执行bash shell脚本

4.3 直接使用bash 或sh 来执行bash shell脚本

4.4 在当前的shell环境中执行bash shell脚本

## 三、变量的定义

#### 1、什么是变量？
可以`变化的数据`，是用来`临时保存数据`的。

#### 2、变量的定义格式
```
变量名=变量值

变量名：用来临时保存数据。
变量值：临时可变化的数据。
```

例如：
```
A = hello shell
echo $A      #调用变量，必须使用$符号
echo ${A}

$A和${A}的区别：
相同点：都是可以调用变量
不同点：${变量名}可以截取变量的某一部分，而$变量名 不可以。
```

#### 3、变量的定义规则
* 变量名`区分大小写`
* 变量名`不能有特殊符号`
    * 如果是有`空格的字符串`给变量赋值时，需要使用`引号`。
* 变量名`不能以数字开头`。
    * 注意点：不能以数字开头不代表不能包含数字。
* 等号的两边`不能有任何空格`。
* 变量名尽量做到`见其名知其意`。
    * 一般来说，变量名使用大小写均可。

#### 4、交互式定义变量read
目的：让用户自己给变量赋值，比较灵活。

语法：`read [选项] 变量名`

常见的选项：

|选项|释义|
|:--:|:--:|
|-p|定义提示用户的信息|
|-n|定义字符数（限制变量值的长度）|
|-s|不显示（不显示用户输入的内容）|
|-t|定义超时时间，默认单位为秒（限制用户输入变量值的时间）|

例子：

![](https://github.com/SolerHo/Software-Testing/blob/master/Shell%E8%84%9A%E6%9C%AC%E7%9F%A5%E8%AF%86/Images/read%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BE%8B%E5%AD%90.png)

变量值来自文件的例子：

![](https://github.com/SolerHo/Software-Testing/blob/master/Shell%E8%84%9A%E6%9C%AC%E7%9F%A5%E8%AF%86/Images/read%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%8D%E6%9D%A5%E8%87%AA%E6%96%87%E4%BB%B6%E7%9A%84%E4%BE%8B%E5%AD%90.png)

#### 5、定义有类型的变量（declare）
目的：给变量做一些限制，固定变量的类型。例如：整型，只读等。

用法：declare 选项 变量名=变量值

常用的选项：

|选项|释义|例子|
|:--:|:--:|:--:|
|-i|将变量设置成整数|declare -I A=23|
|-r|定义`只读`变量|declare -r B=shell01|
|-a|定义`普通`数组；查看`普通`数组
|-A|定义`关联`数组；查看`关联`数组|
|-x|将变量通过环境导出|declare -x AA=1234 等于 export AA=1234|

## 四、变量的分类

1、**本地变量**：当前用户自定义的变量，当前进程中有效，其他的进程及当前进程的子进程无效。

2、**环境变量**：当前进程有效，且可以呗子进程调用。
* env  — —— 查看当前用户的环境变量
* set    ——— 查询当前用户的所有变量（临时变量与环境变量）
* export 变量名=变量值 或者是 变量名=变量值;export 变量名

![](https://github.com/SolerHo/Software-Testing/blob/master/Shell%E8%84%9A%E6%9C%AC%E7%9F%A5%E8%AF%86/Images/%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB%E4%B9%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png)

3、**全局变量**：所有的用户和程序都能调用，且继承、新建的用户也默认能调用。
相关配置文件的介绍

|文件名|说明|备注|
|:--:|:--:|:--:|
|$HOME/.bashrc|当前用户的bash信息，用户登陆时读取|定义别名、umaks、函数等|
|$HOME/.bash_profile|当前用户的环境变量，用户登陆时读取|
|$HOME/.bash_logout|当前用户退出当前shell时最后读取|定义用户退出时执行的程序|
|$/etc/bashrc|全局的bash信息，所有用户都有效。|
|$/etc/profile|全局环境变量信息|系统和用户都生效。|

注意点：以上的`文件修改`后，都需要`重新source让其生效或者是退出重新登录`。

用户登陆系统读取相关文件的顺序
```
* /etc/profile
* $HOME/.bash_profile
* $HOME/.bashrc
* /etc/.bashrc
* /etc/.bash_logout
```
4、**系统变量**
**系统变量（内置bash中变量）**：shell已经固定好自身的名字和作用。

|内置系统变量|含义|
|:--:|:--|
|$?|上一条命令执行后返回的状态，状态值为0表示执行正常。非0表示执行异常或错误。|
|$0|当前执行的程序或脚本名|
|$#|脚本后面接的是参数的个数|
|$*|脚本后面所有的参数，参数当成一个整体输出，每一个变量参数之间用空格隔开。|
|$@|脚本后面所有的参数，参数是独立，也是全部输出。|
|$1-$9|脚本后面的位置参数，$1表示第一个位置参数。|
|${10}-${n}|位置参数的扩展，第10个位置变量起必须扩起来（两位数字起就扩起来。|
|$$|当前所在进程的进程号，如echo $$|
|$!|后台运行的最后一个进程号（当前终端）。|
|!$|调用最后一条命令历史中的参数|

实践操作：

![](https://github.com/SolerHo/Software-Testing/blob/master/Shell%E8%84%9A%E6%9C%AC%E7%9F%A5%E8%AF%86/Images/%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9E%E8%B7%B5.png)


五、四则运算






